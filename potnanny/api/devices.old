









import logging
import datetime
import asyncio
from aiohttp import web
from sqlalchemy import func
from sqlalchemy.sql import text
from sqlalchemy.orm import selectinload
from potnanny.utils import datetime_from_iso
from potnanny.models.device import Device, DeviceSchema
from potnanny.locks import LOCKS
from potnanny.controllers.switch import switch_device
from potnanny.controllers.poll import Poller
from potnanny.models.measurement import Measurement
from potnanny.models.utils import (get_class_objects, update_class_object,
    delete_class_object, exec_statement)
from potnanny.utils.times import datetime_from_sqlite


routes = web.RouteTableDef()
logger = logging.getLogger(__name__)


@routes.get('/api/v1.0/devices')
async def get_list(request):
    params = request.rel_url.query
    objects = await get_class_objects(Device, None)
    if not objects:
        return web.json_response({
            "status": "error", "msg": "no data"}, status=404)

    if params and 'room_id' in params:
        pid = int(params['room_id'])
        payload = [
            o.as_dict() for o in objects if o['room_id'] == pid]
    else:
        payload = [o.as_dict() for o in objects]

    try:
        mtypes = await get_all_mtypes()
        for o in payload:
            if o['id'] in mtypes and mtypes[o['id']]:
                o['plugin_reports'] = mtypes[o['id']]
    except:
        pass

    return web.json_response({
        "status": "ok", "msg": payload}, status=200)


@routes.post('/api/v1.0/devices')
async def create(request):
    jsondata = await request.json()
    schema = DeviceSchema()
    data = schema.load(jsondata)
    try:
        object = Device(**data)
        await object.insert()
        return web.json_response({
            "status": "ok", "msg": object.as_dict()}, status=201)
    except Exception as x:
        return web.json_response({
            "status": "error", "msg": str(x) }, status=500)


@routes.get('/api/v1.0/devices/measurements')
async def get_all_measurements(request):
    payload = await get_all_device_measurements()
    return web.json_response({
        "status": "ok", "msg": payload}, status=200)


@routes.get('/api/v1.0/devices/measurement-types')
async def get_all_measurement_types(request):
    payload = await get_all_device_measurement_types()
    return web.json_response({
        "status": "ok", "msg": payload}, status=200)


@routes.get('/api/v1.0/devices/{pk}')
async def get(request):
    payload = None
    pk = int(request.match_info['pk'])
    object = await get_class_objects(Device, pk)
    if not object:
        return web.json_response({
            "status": "error", "msg": "object id %d not found" % pk},
            status=404)

    payload = object.as_dict()
    try:
        payload['plugin_reports'] = await get_device_mtypes(payload['id'])
    except:
        pass

    return web.json_response({
        "status": "ok", "msg": payload}, status=200)


@routes.patch('/api/v1.0/devices/{pk}')
async def patch(request):
    pk = int(request.match_info['pk'])
    jsondata = await request.json()
    schema = DeviceSchema()
    data = schema.load(jsondata)
    object = await update_class_object(Device, pk, data)
    return web.json_response({
        "status": "ok", "msg": object.as_dict()}, status=200)


@routes.delete('/api/v1.0/devices/{pk}')
async def delete(request):
    pk = int(request.match_info['pk'])
    object = await delete_class_object(Device, pk)
    if object is None:
        return web.json_response({
            "status": "error", "msg": "not found"}, status=404)

    return web.json_response({
        "status": "ok", "msg": ""}, status=200)


@routes.get('/api/v1.0/devices/{pk}/measurements')
async def get_measurements(request):
    pk = int(request.match_info['pk'])
    results = await get_device_measurements(pk)
    if not results:
        return web.json_response({
            "status": "error", "msg": "device id %d no measurements" % pk},
            status=404)

    return web.json_response({
        "status": "ok", "msg": results}, status=200)


@routes.get('/api/v1.0/devices/{pk}/measurement-types')
async def get_measurement_types(request):
    pk = int(request.match_info['pk'])
    results = await get_device_mtypes(pk)
    if not results:
        return web.json_response({
            "status": "error", "msg": "device id %d no measurements" % pk},
            status=404)

    return web.json_response({
        "status": "ok", "msg": results}, status=200)


@routes.get('/api/v1.0/devices/{pk}/graph')
async def graph(request):

    pk = int(request.match_info['pk'])
    hours = 24
    measurement = 'temperature'

    try:
        hours = request.rel_url.query['hours']
    except:
        pass

    try:
        measurement = request.rel_url.query['measurement']
    except:
        pass

    results = await get_device_graph(pk, measurement, hours)
    if not results:
        return web.json_response({
            "status": "error", "msg": "device id %d no graph measurements" % pk},
            status=404)

    return web.json_response({
        "status": "ok", "msg": results}, status=200)


@routes.get('/api/v1.0/devices/{pk}/keycode')
async def get_keycode(request):
    pk = int(request.match_info['pk'])
    device = await get_class_objects(Device, pk)
    if not device:
        return web.json_response({
            "status": "error", "msg": "not found"}, status=404)

    if (not hasattr(device.plugin, 'is_key_required') or
        device.plugin.is_key_required is not True):
        return web.json_response({
            "status": "error", "msg": "not a valid request for this device"},
                status=405)

    secret = None
    try:
        if 'bluetooth' in LOCKS and LOCKS['bluetooth'] is not None:
            async with LOCKS['bluetooth'] as lock:
                secret = await device.plugin.scan_key()
        else:
            secret = await device.plugin.scan_key()
    except Exception as x:
        logger.debug(x)

    if secret:
        return web.json_response({
            "status": "ok", "msg": secret}, status=200)
    else:
        return web.json_response({
            "status": "error", "msg": "key code not detected before timeout"},
            status=404)


@routes.post('/api/v1.0/devices/{pk}/poll')
async def poll_individual(request):
    pk = int(request.match_info['pk'])

    logger.debug("Polling device %d measurements" % pk)
    p = Poller()
    measurements = await p.poll_id(pk)
    if measurements:
        return web.json_response({
            "status": "ok", "msg": result}, status=200)
    else:
        return web.json_response({
            "status": "error", "msg": "error polling device %d" % pk},
            status=405)


@routes.post('/api/v1.0/devices/{pk}/on')
async def switch_on(request):
    outlet = 1
    pk = int(request.match_info['pk'])
    params = request.rel_url.query
    try:
        if params and 'outlet' in params:
            outlet = int(params['outlet'])
    except Exception as x:
        logger.warning(x)

    logger.debug("Switching device %d, outlet %d ON" % (pk, outlet))
    result = await switch_device(pk, outlet, 1)
    if result is None or result is False:
        return web.json_response({
            "status": "error", "msg": "error switching device %d" % pk},
            status=405)

    return web.json_response({
        "status": "ok", "msg": result}, status=200)


@routes.post('/api/v1.0/devices/{pk}/off')
async def switch_off(request):
    outlet = 1
    pk = int(request.match_info['pk'])
    params = request.rel_url.query
    try:
        if params and 'outlet' in params:
            outlet = int(params['outlet'])
    except Exception as x:
        logger.warning(x)

    logger.debug("Switching device %d, outlet %d OFF" % (pk, outlet))
    result = await switch_device(pk, outlet, 0)
    if result is None or result is False:
        return web.json_response({
            "status": "error", "msg": "error switching device %d" % pk},
            status=405)

    return web.json_response({
        "status": "ok", "msg": result}, status=200)


async def get_all_device_measurements(pk):
    raw = {}
    stmt = text("""
        SELECT
            d.id, d.name, m.type, m.value, max(m.created), d.room_id
        FROM
            measurements as m,
            devices as d
        WHERE
            m.device_id = d.id
        GROUP BY
            d.room_id,
            m.device_id,
            m.type
        ORDER BY
            d.room_id,
            m.device_id
    """)

    rows = await exec_statement(stmt)
    for r in rows.all():
        if r[0] not in raw:
            raw[r[0]] = {
                'id': r[0],
                'name': r[1],
                'room_id': r[-1],
                'created': r[4],
                'values': {r[2]: r[3]}
            }
        else:
            raw[r[0]]['values'][r[2]] = r[3]

    return [data for data in raw.values()]


async def get_device_measurements(pk):
    results = {}
    stmt = text("""
        SELECT
            m.device_id, m.type, m.value, max(m.created)
        FROM
            measurements as m
        WHERE
            m.device_id = %d
        GROUP BY
            m.device_id,
            m.type
        ORDER BY
            m.type ASC
    """ % pk)

    rows = await exec_statement(stmt)
    for r in rows.all():
        if not results:
            results = {
                'id': r[0],
                'created': r[3].isoformat() + "Z",
                'values': {}
            }

        results['values'][r[1]] = r[2]

    return results


async def get_device_graph(pk, measurement, hours=8):
    """
    Get graph data for room measurements
    """

    graph = {
        'type': 'line',
        'options': {
            'maintainAspectRatio': False,
            'responsive': True,
            'plugins': {
                'title': {
                    'display': True,
                    'text': measurement.upper(),
                }
            }
        },
        'data': {
            'datasets': []
        }
    }
    now = datetime.datetime.utcnow()
    start = str(now - datetime.timedelta(hours=hours))

    stmt = text("""
        SELECT
          d.id, d.name, m.type, m.value, m.created
        FROM
          measurements as m,
          devices as d
        WHERE
            d.id = %d
        AND
            m.device_id = d.id
        AND
            m.type = '%s'
        AND
            m.created >= '%s'
        ORDER BY
            m.created
    """ % (pk, measurement, start))

    data = {}
    labels = []
    rows = await exec_statement(stmt)
    for r in rows.all():
        if r[0] not in data:
            data[r[0]] = {
                'label': r[1],
                'data': [] }
        dt = datetime_from_sqlite(r[4]).isoformat() + "Z"
        labels.append(dt)
        data[r[0]]['data'].append({
            'y': r[3],
            'x': dt,
        })

    graph['data']['labels'] = sorted(list(set(labels)))
    graph['data']['datasets'] = [v for v in data.values()]
    return graph


async def get_device_mtypes(pk):
    results = []
    stmt = text("""
        SELECT
            m.type
        FROM
            measurements as m
        WHERE
            m.device_id = %d
        GROUP BY
            m.type
        ORDER BY
            m.type ASC
    """ % pk)

    rows = await exec_statement(stmt)
    for r in rows.all():
        results.append(r[0])

    return results


async def get_all_mtypes():
    results = {}
    stmt = text("""
        SELECT
            m.device_id, m.type
        FROM
            measurements as m
        GROUP BY
            m.device_id,
            m.type
        ORDER BY
            m.device_id,
            m.type
    """)

    rows = await exec_statement(stmt)
    for r in rows.all():
        if r[0] not in results:
            results[r[0]] = []

        results[r[0]].append(r[1])

    return results
